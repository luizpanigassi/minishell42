header

#ifndef MINISHELL_H
# define MINISHELL_H

# include "../libft/libft.h"

# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>
# include <string.h>
# include <sys/types.h>
# include <sys/wait.h>
# include <errno.h>
# include <signal.h>
# include <readline/readline.h>
# include <readline/history.h>
# include <dirent.h>
# include <limits.h>

# define CMD_NOT_FOUND 127
# define PERM_DENIED 126
# define SYNTAX_ERROR 2

// Parsing structure
typedef enum e_token
{
	T_WORD,
	T_SINGLE_QUOTED,
	T_DOUBLE_QUOTED,
	T_PIPE,
	T_REDIR_OUT,
	T_REDIR_IN,
	T_APPEND,
	T_HEREDOC,
	T_EOF
}	t_token;

typedef struct s_parse
{
	char	*input;
	int		pos;
	char	curr_char;
	t_token	token_type;
	char	*token_value;
}	t_parse;

typedef struct s_redir {
	t_token			type;// T_REDIR_IN, T_REDIR_OUT, etc.
	char			*filename;// Target file
	struct s_redir	*next;// For multiple redirections
}	t_redir;

typedef struct s_cmd {
	char			**args; // Command arguments (e.g., ["ls", "-l"])
	t_redir			*redirections; // List of redirections
	struct s_cmd	*next; // For pipe
}	t_cmd;

typedef struct s_arg {
	char	*value;
	t_token	type;
}	t_arg;

/*
** Global variable to store the exit status of commands
** volatile sig_atomic_t ensures safe access in signal handlers
*/
extern volatile sig_atomic_t	g_exit_status;

// INPUT
void	handle_error(char *message);
char	*get_cmd_path(char *cmd);
char	*expand_variables(const char *input);
void	exec_external_command(t_cmd *cmd);

// BUILTIN
int		is_builtin(char **args);
int		exec_cd(char **args);
int		exec_exit(char **args);
int		exec_echo(char **args);
int		exec_builtin(char **args);
int		exec_env(char **args);
int		exec_pwd(char **args);
int		exec_export(char **args);
int		exec_unset(char **args);
char	**ft_copy_env(char **env);
void	update_env_var(char *var, char *value);
void	ensure_var_exported(char *var_name);
char	**build_expanded_args(t_list *args);

// SIGNALS
void	handle_sigint(int sig);
void	setup_parent_signals(void);
void	setup_child_signals(void);

// PARSING
void	init_parser(t_parse *p, char *input);
void	next_token(t_parse *p);
t_cmd	*parse_args(t_parse *p);
int		create_heredoc(const char *delimiter);
int		is_redirection(t_token type);
t_cmd	*parse_pipeline(t_parse *p);

// UTILS
void	ft_free_array(char **array);
void	free_cmd(t_cmd *cmd);
int		ft_strcmp(const char *s1, const char *s2);
char	**ft_array_append(char **array, char *new_element);
int		ft_isnumber(const char *str);
int		is_valid_var_name(const char *name);
void	print_export_declarations(void);
size_t	ft_strlen_size(const char *s);
char	**ft_array_append(char **array, char *new_element);
char	*ft_strjoin3(const char *s1, const char *s2, const char *s3);
void	free_arg(void *arg);
char	*ft_strjoin_free(char *s1, const char *s2);
char	*ft_strjoin_char(char *str, char c);
size_t	ft_cmd_size(t_cmd *pipeline);
void	free_redirections(t_redir *redirs);

// Helper functions for parsing
int		ft_isspace(int c);
void	next_char(t_parse *p);
int		is_special_char(char c);
char	**list_to_array(t_list *lst);
int		handle_redirections(int pipe_in, int pipe_out, t_redir *redirections);

//Exit status
void	set_exit_status(int status);
int		get_exit_status(void);

#endif

builtin.c

#include "minishell.h"

extern volatile sig_atomic_t g_exit_status;

/*
** Checks if a command is a builtin
** @param tokens Array of command tokens
** @return 1 if builtin, 0 otherwise
*/
int is_builtin(char **tokens)
{
	const char *builtins[] = {"echo", "cd", "pwd", "export",
							  "unset", "env", "exit", NULL};
	int i;

	if (!tokens || !tokens[0])
		return (0);
	i = -1;
	while (builtins[++i])
	{
		if (ft_strcmp(tokens[0], builtins[i]) == 0)
			return (1);
	}
	return (0);
}

/*
** Executes the appropriate builtin function based on command
** @param args Command arguments
** @return Exit status of the builtin command
*/
int exec_builtin(char **args)
{
	if (ft_strcmp(args[0], "echo") == 0)
		return (exec_echo(args));
	if (ft_strcmp(args[0], "cd") == 0)
		return (exec_cd(args));
	if (ft_strcmp(args[0], "pwd") == 0)
		return (exec_pwd(args));
	if (ft_strcmp(args[0], "export") == 0)
		return (exec_export(args));
	if (ft_strcmp(args[0], "unset") == 0)
		return (exec_unset(args));
	if (ft_strcmp(args[0], "env") == 0)
		return (exec_env(args));
	if (ft_strcmp(args[0], "exit") == 0)
		return (exec_exit(args));
	return (0);
}

/*
** Changes the current directory
** @param args Command arguments (args[1] is the target directory)
** @return 0 on success, 1 on failure
*/
int exec_cd(char **args)
{
	char *oldpwd = getcwd(NULL, 0);
	char *path = NULL;
	char *newpwd;

	if (!oldpwd)
		return (perror("cd"), 1);

	// Determine path (existing logic)
	if (!args[1] || ft_strcmp(args[1], "~") == 0)
		path = getenv("HOME");
	else if (ft_strcmp(args[1], "-") == 0)
		path = getenv("OLDPWD");
	else
		path = args[1];

	// Handle errors (existing error checking)
	if (chdir(path) != 0)
	{
		// ... error message logic ...
		free(oldpwd);
		return 1;
	}

	newpwd = getcwd(NULL, 0);
	if (!newpwd)
	{
		free(oldpwd);
		return (perror("cd"), 1);
	}

	// Update environment - DON'T FREE THESE AFTER
	update_env_var("OLDPWD", oldpwd);
	update_env_var("PWD", newpwd);

	return 0;
}

/*
** Exits the shell with optional status code
** @param args Command arguments (args[1] is optional exit status)
** @return Does not return on success, returns 1 if too many arguments
*/
int exec_exit(char **args)
{
	int status;

	status = 0;
	if (args[1] && args[2])
	{
		ft_putstr_fd("minishell: exit error: too many arguments\n", STDERR_FILENO);
		return (1); // Return error code 1 (shell does NOT exit)
	}

	if (args[1])
	{
		if (ft_isnumber(args[1]))
			status = ft_atoi(args[1]);
		else
		{
			ft_putstr_fd("minishell: exit error: numeric argument required\n", STDERR_FILENO);
			status = 2;
			exit(status);
		}
	}
	printf("Exiting minishell, goodbye!\n");
	rl_clear_history();
	exit(status);
}

/*
** Prints arguments to stdout with optional newline suppression
** @param args Command arguments (-n flag suppresses newline)
** @return Always returns 0
*/
int exec_echo(char **args) // use -n
{
	int i;
	int nl_flag;

	i = 1;
	nl_flag = 0;
	if (args[1] && ft_strcmp(args[1], "-n") == 0)
	{
		nl_flag = 1;
		i++;
	}
	while (args[i])
	{
		ft_putstr_fd(args[i], STDOUT_FILENO);
		if (args[++i])
			ft_putchar_fd(' ', STDOUT_FILENO);
	}
	if (!nl_flag)
		ft_putchar_fd('\n', STDOUT_FILENO);
	return (0);
}

/*
** Prints the current environment variables
** @param args Ignored
** @return Always returns 0
*/
int exec_env(char **args)
{
	extern char **environ;
	int i;

	(void)args;
	i = -1;
	while (environ[++i])
		printf("%s\n", environ[i]);
	return (0);
}

/*
** Prints the current working directory
** @param args Ignored
** @return 0 on success, 1 on failure
*/
int exec_pwd(char **args)
{
	char *cwd;

	(void)args;
	cwd = getcwd(NULL, 0); // Let getcwd allocate memory
	if (cwd)
	{
		printf("%s\n", cwd);
		free(cwd);
		return (0);
	}
	else
	{
		perror("minishell: pwd");
		return (1);
	}
}

/**
 * @brief Executes the 'export' builtin to set environment variables.
 * @param args Array of arguments (e.g., ["export", "VAR=value"]).
 * @return 0 on success, 1 if any invalid variable name is encountered.
 */
int exec_export(char **args)
{
	extern char **environ;

	if (!args[1])
	{
		print_export_declarations();
		return (0);
	}

	int ret = 0;
	int i = 1;
	while (args[i])
	{
		char *eq_pos = ft_strchr(args[i], '=');
		char *var_name = NULL;
		char *value = NULL;

		if (eq_pos)
		{
			var_name = ft_substr(args[i], 0, eq_pos - args[i]);
			value = ft_strdup(eq_pos + 1);
		}
		else
			var_name = ft_strdup(args[i]);

		if (!is_valid_var_name(var_name))
		{
			ft_putstr_fd("minishell: export: `", STDERR_FILENO);
			ft_putstr_fd(args[i], STDERR_FILENO);
			ft_putstr_fd("': not a valid identifier\n", STDERR_FILENO);
			ret = 1;
			free(var_name); // Free only on error
			free(value);	// Free only on error
			i++;
			continue;
		}

		if (eq_pos)
			update_env_var(var_name, value); // Ownership transferred
		else
			ensure_var_exported(var_name); // Ownership transferred
		i++;
	}
	return (ret);
}

/*
** Creates a copy of the environment variables array
** @param original Original environment array
** @return New allocated copy of the environment
*/
char **ft_copy_env(char **original)
{
	int count = 0;
	while (original[count])
		count++;

	char **copy = malloc(sizeof(char *) * (count + 1));
	if (!copy)
		return (NULL);

	int i = 0;
	while (original[i])
	{
		copy[i] = ft_strdup(original[i]);
		i++;
	}
	copy[count] = NULL;
	return (copy);
}

/**
 * @brief Executes the 'unset' builtin to remove environment variables.
 * @param args Array of arguments (e.g., ["unset", "VAR"]).
 * @return 0 on success, 1 if any invalid variable name is encountered.
 */
int exec_unset(char **args)
{
	extern char **environ;

	if (!args[1])
		return (0);

	int ret = 0;
	int i = 1;
	while (args[i])
	{
		if (!is_valid_var_name(args[i]))
		{
			ft_putstr_fd("minishell: unset: `", STDERR_FILENO);
			ft_putstr_fd(args[i], STDERR_FILENO);
			ft_putstr_fd("': not a valid identifier\n", STDERR_FILENO);
			ret = 1;
			i++;
			continue;
		}

		char **env_ptr = environ;
		while (*env_ptr)
		{
			char *eq = ft_strchr(*env_ptr, '=');
			size_t var_len = eq ? eq - *env_ptr : ft_strlen(*env_ptr);

			if (ft_strncmp(*env_ptr, args[i], var_len) == 0 && var_len == ft_strlen_size(args[i]))
			{
				free(*env_ptr);
				char **ptr = env_ptr;
				while (*ptr)
				{
					*ptr = *(ptr + 1);
					ptr++;
				}
				break;
			}
			env_ptr++;
		}
		i++;
	}
	return (ret);
}

/* Environment variable operations */
/**
 * @brief Updates or adds an environment variable.
 * @param var Variable name (ownership transferred).
 * @param value Variable value (ownership transferred).
 */
void update_env_var(char *var, char *value)
{
	extern char **environ;
	char *new_entry = NULL;

	// Create new environment entry
	if (value)
		new_entry = ft_strjoin3(var, "=", value);
	else
		new_entry = ft_strjoin(var, "=");

	// Find and replace existing entry
	char **env_ptr = environ;
	while (*env_ptr)
	{
		char *eq = ft_strchr(*env_ptr, '=');
		if (eq && ft_strncmp(*env_ptr, var, eq - *env_ptr) == 0)
		{
			free(*env_ptr);
			*env_ptr = new_entry;
			free(value); // Only free the value parameter
			return;
		}
		env_ptr++;
	}

	// Add new entry
	environ = ft_array_append(environ, new_entry);
	free(value); // Only free the value parameter
}

/*
** Ensures a variable exists in the environment (without value if not present)
** @param var_name Variable name to check/export
*/
void ensure_var_exported(char *var_name)
{
	extern char **environ;
	char **env_ptr = environ;
	int exists = 0;

	while (*env_ptr && !exists)
	{
		char *eq = ft_strchr(*env_ptr, '=');
		if (eq && ft_strncmp(*env_ptr, var_name, eq - *env_ptr) == 0)
			exists = 1;
		env_ptr++;
	}
	if (!exists)
		update_env_var(var_name, NULL);
	else
		free(var_name); // Free here since update_env_var no longer owns it
}

exit_status.c

#include "minishell.h"

/**
 * @brief Updates the global exit status variable.
 * @param status Exit code to store (0-255).
 */
void set_exit_status(int status)
{
	g_exit_status = status;
}

/**
 * @brief Retrieves the global exit status.
 * @return Last exit status of foreground commands.
 */
int get_exit_status(void)
{
	return (g_exit_status);
}

input.c

#include "minishell.h"

/*
** Prints error message and exits
** @param message Error message to display
*/
void handle_error(char *message)
{
	perror(message);
	exit(EXIT_FAILURE);
}

/**
 * @brief Locates the full path of a command using PATH.
 * @param cmd Command name (e.g., "ls").
 * @return Allocated full path (e.g., "/bin/ls") or NULL if not found.
 * Caller must free the returned string.
 */
char *get_cmd_path(char *cmd)
{
	char **paths;
	char *full_path;
	char *dir_slash;
	int i;

	// Handle absolute paths and commands with path specified
	if (ft_strchr(cmd, '/') != NULL)
	{
		if (access(cmd, F_OK) == -1)
			return NULL; // Not found
		if (access(cmd, X_OK) == -1)
		{
			g_exit_status = PERM_DENIED; // Set global error
			return NULL;
		}
		return ft_strdup(cmd);
	}
	// Get PATH environment variable
	char *path_env = getenv("PATH");
	if (!path_env)
		return (NULL);
	// Split PATH into individual directories
	paths = ft_split(path_env, ':');
	if (!paths)
		return (NULL);

	i = -1;
	while (paths[++i])
	{
		// Create directory + slash
		dir_slash = ft_strjoin(paths[i], "/");
		if (!dir_slash)
		{
			ft_free_array(paths);
			return (NULL);
		}
		// Create full path
		full_path = ft_strjoin(dir_slash, cmd);
		free(dir_slash);
		if (!full_path)
		{
			ft_free_array(paths);
			return (NULL);
		}
		// Check if executable exists
		if (access(full_path, X_OK) == 0)
		{
			ft_free_array(paths);
			return (full_path);
		}
		free(full_path);
	}
	ft_free_array(paths);
	return (NULL);
}

/**
 * @brief Expands environment variables and `$?` in a string.
 *
 * @param input The input string to process.
 * @return char* New string with variables expanded. Must be freed by the caller.
 *
 * @note Expansion rules:
 * - `$VAR` â†’ Replaced with environment variable value.
 * - `$?` â†’ Replaced with the last exit status.
 * - Single-quoted strings suppress expansion.
 * - Double-quoted strings allow `$VAR` and `$?` expansion.
 */
char *expand_variables(const char *input)
{
	char *result = ft_strdup("");
	size_t i = 0;

	while (input[i])
	{
		if (input[i] == '$' && (input[i + 1] == '?' || ft_isalpha(input[i + 1]) || input[i + 1] == '_'))
		{
			i++; // Skip $
			if (input[i] == '?')
			{
				char *exit_status = ft_itoa(get_exit_status());
				result = ft_strjoin_free(result, exit_status);
				free(exit_status);
				i++;
			}
			else
			{
				size_t start = i;
				while (input[i] && (ft_isalnum(input[i]) || input[i] == '_'))
					i++;
				char *var_name = ft_substr(input, start, i - start);
				char *var_value = getenv(var_name);
				if (var_value)
					result = ft_strjoin_free(result, var_value);
				free(var_name);
			}
		}
		else
		{
			result = ft_strjoin_char(result, input[i++]);
		}
	}
	return result;
}

/**
 * @brief Executes an external command in a child process.
 * @param cmd Command structure with arguments and redirections.
 * @note Terminates the process on completion or error.
 */
void exec_external_command(t_cmd *cmd)
{
	extern char **environ;

	char *path = get_cmd_path(cmd->args[0]);
	if (!path)
	{
		ft_putstr_fd("minishell: ", STDERR_FILENO);
		ft_putstr_fd(cmd->args[0], STDERR_FILENO);
		ft_putstr_fd(": command not found\n", STDERR_FILENO);
		exit(CMD_NOT_FOUND);
	}

	execve(path, cmd->args, environ);
	perror("minishell");
	free(path);
	exit(EXIT_FAILURE);
}


main.c

#include "minishell.h"

volatile sig_atomic_t g_exit_status = 0;

/**
 * @brief Frees a command pipeline and associated resources.
 * @param pipeline Linked list of command structures.
 */
void free_pipeline(t_cmd *pipeline)
{
	t_cmd *current;
	t_redir *redir, *tmp_redir;

	while (pipeline)
	{
		current = pipeline;
		pipeline = pipeline->next;

		// Free arguments
		if (current->args)
			ft_free_array(current->args);

		// Free redirections
		redir = current->redirections;
		while (redir)
		{
			tmp_redir = redir;
			redir = redir->next;
			free(tmp_redir->filename);
			free(tmp_redir);
		}

		free(current);
	}
}

/**
 * @brief Executes a single command with I/O redirection.
 * @param cmd Command structure to execute.
 * @param pipe_in Input file descriptor (or -1).
 * @param pipe_out Output file descriptor (or -1).
 */
void execute_command(t_cmd *cmd, int pipe_in, int pipe_out)
{
	pid_t pid;
	extern char **environ;

	// Always fork for pipeline commands
	pid = fork();
	if (pid == 0)
	{
		// Child process
		setup_child_signals();
		handle_redirections(pipe_in, pipe_out, cmd->redirections);

		if (is_builtin(cmd->args))
		{
			exec_builtin(cmd->args);
			exit(g_exit_status); // Make sure to exit after builtin
		}
		else
		{
			char *cmd_path = get_cmd_path(cmd->args[0]);
			if (!cmd_path)
			{
				ft_putstr_fd("minishell: command not found: ", STDERR_FILENO);
				ft_putstr_fd(cmd->args[0], STDERR_FILENO);
				ft_putstr_fd("\n", STDERR_FILENO);
				exit(CMD_NOT_FOUND);
			}

			// Execute the command with the current environment
			execve(cmd_path, cmd->args, environ);

			// If execve returns, it failed
			perror("minishell");
			free(cmd_path);
			exit(EXIT_FAILURE);
		}
	}
	else if (pid < 0)
	{
		perror("fork");
	}
}

/*
** Executes a pipeline of commands with proper piping
** @param pipeline Command pipeline to execute
** @return Exit status of the last command in pipeline
*/
int execute_pipeline(t_cmd *pipeline)
{
	int prev_pipe[2] = {-1, -1};
	int next_pipe[2];
	pid_t *child_pids;
	int cmd_count = ft_cmd_size(pipeline);
	int status;
	int i = 0;

	if (cmd_count == 0)
		return (1);

	child_pids = malloc(sizeof(pid_t) * cmd_count);
	if (!child_pids)
		return (1);

	t_cmd *current = pipeline;
	while (current)
	{
		if (current->next && pipe(next_pipe) < 0)
		{
			perror("minishell: pipe");
			free(child_pids);
			return (1);
		}

		pid_t pid = fork();
		if (pid == 0) // Child process
		{
			setup_child_signals();
			// Handle pipe redirections
			handle_redirections(prev_pipe[0],
								(current->next ? next_pipe[1] : -1),
								current->redirections);

			// Close all pipe ends in child
			if (prev_pipe[0] != -1)
				close(prev_pipe[0]);
			if (current->next)
			{
				close(next_pipe[0]);
				close(next_pipe[1]);
			}

			if (is_builtin(current->args))
				exit(exec_builtin(current->args));
			else
				exec_external_command(current);
		}
		else if (pid > 0) // Parent process
		{
			child_pids[i++] = pid;
			// Close parent's copy of unused pipe ends
			if (prev_pipe[0] != -1)
				close(prev_pipe[0]);
			close(prev_pipe[1]);

			if (current->next)
			{
				prev_pipe[0] = next_pipe[0];
				prev_pipe[1] = next_pipe[1];
			}
			else
			{
				prev_pipe[0] = -1;
				prev_pipe[1] = -1;
			}
		}
		else // Fork failed
		{
			perror("minishell: fork");
			free(child_pids);
			return (1);
		}
		current = current->next;
	}

	// Close any remaining pipe ends in parent
	if (prev_pipe[0] != -1)
		close(prev_pipe[0]);
	if (prev_pipe[1] != -1)
		close(prev_pipe[1]);

	// Wait for all children
	int last_status = 0;
	int wpid;
	while ((wpid = waitpid(-1, &status, 0)) > 0)
	{
		if (wpid == -1)
		{
			if (errno == ECHILD)
				break; // No more children
			continue;
		}

		// Update status only for last command
		if (WIFEXITED(status))
		{
			for (int j = 0; j < cmd_count; j++)
			{
				if (child_pids[j] == wpid && j == cmd_count - 1)
					last_status = WEXITSTATUS(status);
			}
		}
	}

	free(child_pids);
	set_exit_status(last_status);
	return (last_status);
}

/*
** Sets up file descriptors for I/O redirection
** @param pipe_in Input file descriptor
** @param pipe_out Output file descriptor
** @param redirections List of redirection specifications
** @return 0 on success, -1 on error
*/
int handle_redirections(int pipe_in, int pipe_out, t_redir *redirections)
{
	// Handle pipe redirections
	if (pipe_in != STDIN_FILENO && pipe_in != -1)
	{
		if (dup2(pipe_in, STDIN_FILENO) == -1)
			return (perror("minishell"), -1);
		close(pipe_in);
	}
	if (pipe_out != STDOUT_FILENO && pipe_out != -1)
	{
		if (dup2(pipe_out, STDOUT_FILENO) == -1)
			return (perror("minishell"), -1);
		close(pipe_out);
	}

	// Handle file redirections
	t_redir *current = redirections;
	while (current)
	{
		int fd = -1;
		if (current->type == T_HEREDOC)
			fd = create_heredoc(current->filename);
		else if (current->type == T_REDIR_IN)
			fd = open(current->filename, O_RDONLY);
		else if (current->type == T_REDIR_OUT)
			fd = open(current->filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
		else if (current->type == T_APPEND)
			fd = open(current->filename, O_WRONLY | O_CREAT | O_APPEND, 0644);

		if (fd == -1)
			return (perror("minishell"), -1);

		if (current->type == T_REDIR_IN || current->type == T_HEREDOC)
		{
			if (dup2(fd, STDIN_FILENO) == -1)
				return (close(fd), perror("minishell"), -1);
		}
		else
		{
			if (dup2(fd, STDOUT_FILENO) == -1)
				return (close(fd), perror("minishell"), -1);
		}
		close(fd);
		current = current->next;
	}
	return (0);
}

/*
** Main shell loop
** @return Exit status of shell
*/
int main(void)
{
	char *input;
	t_cmd *pipeline;
	extern char **environ;
	char **env_copy;

	env_copy = ft_copy_env(environ);
	environ = env_copy;
	setup_parent_signals();
	while (1)
	{
		setup_parent_signals();
		input = readline("minishell> ");
		if (!input)
		{
			ft_putstr_fd("exit\n", STDOUT_FILENO);
			break;
		}

		if (ft_strlen(input) > 0)
			add_history(input);
		else
		{
			free(input);
			continue;
		}

		t_parse parser;
		init_parser(&parser, input);
		pipeline = parse_pipeline(&parser);

		if (!pipeline || !pipeline->args)
		{
			free(input);
			free_pipeline(pipeline);
			setup_parent_signals();
			continue;
		}

		// ðŸš¨ Handle "exit" directly in the parent process
		if (pipeline && !pipeline->next && is_builtin(pipeline->args))
		{
			int saved_stdin = dup(STDIN_FILENO);
			int saved_stdout = dup(STDOUT_FILENO);
			int saved_stderr = dup(STDERR_FILENO);

			// Apply redirections (no pipes: -1, -1)
			if (handle_redirections(-1, -1, pipeline->redirections) != 0)
			{
				set_exit_status(1); // Redirection error
				close(saved_stdin);
				close(saved_stdout);
				close(saved_stderr);
			}
			else
			{
				int result = exec_builtin(pipeline->args);
				set_exit_status(result);

				// Restore original descriptors
				dup2(saved_stdin, STDIN_FILENO);
				dup2(saved_stdout, STDOUT_FILENO);
				dup2(saved_stderr, STDERR_FILENO);
			}

			// Close saved descriptors
			close(saved_stdin);
			close(saved_stdout);
			close(saved_stderr);

			if (ft_strcmp(pipeline->args[0], "exit") == 0)
			{
				free(input);
				free_pipeline(pipeline);
				if (get_exit_status() == 1)
					continue;
				else
					exit(get_exit_status());
			}
		}
		else
		{
			execute_pipeline(pipeline);
		}

		free(input);
		free_pipeline(pipeline);
		setup_parent_signals();
	}
	rl_clear_history(); // Clear history entries
	rl_reset_terminal(NULL);
	return 0;
}

parser.c

#include "minishell.h"

/**
 * @brief Initializes the parser state for new input.
 * @param p Parser structure to initialize.
 * @param input Input string to parse.
 */
void init_parser(t_parse *p, char *input)
{
	p->input = input;
	p->pos = 0;
	p->curr_char = input[0]; // Initialize first character
	p->token_type = T_EOF;	 // Default to EOF
	p->token_value = NULL;
}

/*
** Skips whitespace characters in input
** @param p Parser structure
*/
static void skip_whitespace(t_parse *p)
{
	while (ft_isspace(p->curr_char))
		next_char(p);
}

/*
** Handles quoted strings in input
** @param p Parser structure
** @param quote Type of quote (' or ")
*/
static void handle_quotes(t_parse *p, char quote)
{
	size_t start = p->pos;
	char *content;

	next_char(p); // Skip opening quote
	while (p->curr_char && (p->curr_char != quote || (p->input[p->pos - 1] == '\\')))
	{
		if (p->curr_char == '\\' && quote == '"')
			next_char(p); // Skip escape char if inside double quotes
		next_char(p);
	}

	if (!p->curr_char)
	{
		ft_putstr_fd("minishell: unmatched quote\n", STDERR_FILENO);
		p->token_type = T_EOF;
		return;
	}

	// Extract content inside quotes (without the quotes themselves)
	content = ft_substr(p->input, start + 1, p->pos - start - 1);

	// Set token type based on quote type
	if (quote == '\'')
		p->token_type = T_SINGLE_QUOTED;
	else
		p->token_type = T_DOUBLE_QUOTED;

	free(p->token_value); // Free previous value
	p->token_value = content;
	next_char(p); // Skip closing quote
}

/*
** Handles regular words in input
** @param p Parser structure
*/
static void handle_word(t_parse *p)
{
	size_t start = p->pos;
	char *sub;

	while (p->curr_char &&
			(!ft_isspace(p->curr_char) || (p->input[p->pos - 1] == '\\')) &&
			!is_special_char(p->curr_char))
	{
		if (p->curr_char == '\\' && p->input[p->pos + 1])
			next_char(p); // Skip backslash
		next_char(p);
	}
	sub = ft_substr(p->input, start, p->pos - start);
	p->token_value = ft_strdup(sub);
	free(sub); // Free the temporary substring
	p->token_type = T_WORD;
}

/*
** Handles special characters (|, >, <, etc.)
** @param p Parser structure
*/
static void handle_special(t_parse *p)
{
	if (p->curr_char == '|')
	{
		p->token_type = T_PIPE;
		p->token_value = ft_strdup("|");
		next_char(p);
	}
	else if (p->curr_char == '>')
	{
		next_char(p);
		if (p->curr_char == '>')
		{
			p->token_type = T_APPEND;
			p->token_value = ft_strdup(">>");
			next_char(p);
		}
		else
		{
			p->token_type = T_REDIR_OUT;
			p->token_value = ft_strdup(">");
		}
	}
	else if (p->curr_char == '<')
	{
		next_char(p);
		if (p->curr_char == '<')
		{
			p->token_type = T_HEREDOC;
			p->token_value = ft_strdup("<<");
			next_char(p);
		}
		else
		{
			p->token_type = T_REDIR_IN;
			p->token_value = ft_strdup("<");
		}
	}
}

/*
** Gets the next token from input
** @param p Parser structure
*/
void next_token(t_parse *p)
{
	skip_whitespace(p);
	free(p->token_value);
	p->token_value = NULL;

	if (!p->curr_char)
	{
		p->token_type = T_EOF;
		return;
	}

	if (p->curr_char == '\'' || p->curr_char == '"')
		handle_quotes(p, p->curr_char);
	else if (is_special_char(p->curr_char))
		handle_special(p);
	else
		handle_word(p);
}

/*
** Parses command arguments and redirections
** @param p Parser structure
** @return Command structure with arguments and redirections
*/
t_cmd *parse_args(t_parse *p)
{
	t_list *args = NULL;			// List to collect command arguments (t_arg structs)
	t_redir *redirs = NULL;			// List of redirection specifications
	t_redir **redir_tail = &redirs; // Pointer to end of redir list for appending
	t_arg *arg;						// Temporary argument storage

	// Process tokens until pipeline or end of input
	while (p->token_type != T_EOF && p->token_type != T_PIPE)
	{
		// Handle words and quoted strings
		if (p->token_type == T_WORD ||
			p->token_type == T_SINGLE_QUOTED ||
			p->token_type == T_DOUBLE_QUOTED)
		{
			// Allocate and populate argument structure
			arg = malloc(sizeof(t_arg));
			if (!arg)
				return (NULL);
			arg->value = ft_strdup(p->token_value); // Copy token value
			arg->type = p->token_type;				// Store quoting type
			ft_lstadd_back(&args, ft_lstnew(arg));	// Add to arguments list
		}
		// Handle redirection operators
		else if (is_redirection(p->token_type))
		{
			t_redir *redir = malloc(sizeof(t_redir));
			if (!redir)
			{
				ft_lstclear(&args, free_arg);
				return (NULL);
			}

			redir->type = p->token_type;
			next_token(p); // Move to filename token

			// Check if filename is valid (word or quoted)
			if (p->token_type != T_WORD &&
				p->token_type != T_SINGLE_QUOTED &&
				p->token_type != T_DOUBLE_QUOTED)
			{
				// Syntax error: print message and clean up
				ft_putstr_fd("minishell: syntax error near unexpected token `", STDERR_FILENO);
				if (p->token_type == T_EOF)
					ft_putstr_fd("newline", STDERR_FILENO);
				else if (p->token_value)
					ft_putstr_fd(p->token_value, STDERR_FILENO);
				else
					ft_putstr_fd(" ", STDERR_FILENO); // Fallback
				ft_putstr_fd("'\n", STDERR_FILENO);

				free(redir);
				ft_lstclear(&args, free_arg);
				free_redirections(redirs); // Free existing redirections
				return (NULL);
			}

			redir->filename = ft_strdup(p->token_value);
			redir->next = NULL;

			// Append to redirection list
			*redir_tail = redir;
			redir_tail = &redir->next;
		}
		next_token(p); // Advance to next token
	}

	// Build command structure
	t_cmd *cmd = malloc(sizeof(t_cmd));
	if (!cmd)
	{
		ft_lstclear(&args, free_arg);
		return (NULL);
	}

	// Convert argument list to expanded string array
	cmd->args = build_expanded_args(args);
	cmd->redirections = redirs; // Attach redirections
	cmd->next = NULL;			// Initialize pipeline pointer

	// Cleanup temporary structures
	ft_lstclear(&args, free_arg); // Free argument list and t_arg structs

	return (cmd);
}

/**
 * @brief Creates a temporary heredoc file.
 * @param delimiter Heredoc termination string.
 * @return File descriptor of the heredoc temp file.
 * @note Automatically deletes the temp file after opening.
 */
int create_heredoc(const char *delimiter)
{
	char *line;
	int tmp_fd = open(".heredoc.tmp", O_WRONLY | O_CREAT | O_TRUNC, 0644);

	while (1)
	{
		line = readline("> ");
		if (!line || ft_strcmp(line, delimiter) == 0)
			break;
		write(tmp_fd, line, ft_strlen(line));
		write(tmp_fd, "\n", 1);
		free(line);
	}
	close(tmp_fd);
	tmp_fd = open(".heredoc.tmp", O_RDONLY);
	unlink(".heredoc.tmp"); // Delete temp file after use
	return tmp_fd;
}

/*
** Checks if a token type is a redirection
** @param type Token type to check
** @return 1 if redirection, 0 otherwise
*/
int is_redirection(t_token type)
{
	return (type == T_REDIR_IN || type == T_REDIR_OUT ||
			type == T_APPEND || type == T_HEREDOC);
}

/*
** Parses a pipeline of commands
** @param p Parser structure
** @return Linked list of command structures
*/
t_cmd *parse_pipeline(t_parse *p)
{
	t_cmd *head = NULL;
	t_cmd **curr = &head;

	next_token(p);

	while (1)
	{
		t_cmd *cmd = parse_args(p);
		if (!cmd)
			break;

		*curr = cmd;
		curr = &cmd->next;

		if (p->token_type != T_PIPE)
			break;

		next_token(p); // Consume the pipe
	}

	return head;
}

/**
 * @brief Converts a list of t_arg structs to an array of expanded strings.
 *
 * @param args Linked list of t_arg structs.
 * @return char** Array of expanded arguments. Must be freed with ft_free_array.
 */
char **build_expanded_args(t_list *args)
{
	int count = ft_lstsize(args);
	char **arr = malloc(sizeof(char *) * (count + 1));
	t_list *current = args;
	int i = 0;

	while (current)
	{
		t_arg *a = (t_arg *)current->content;
		char *expanded;

		if (a->type == T_SINGLE_QUOTED)
			expanded = ft_strdup(a->value); // No expansion
		else
			expanded = expand_variables(a->value); // Expand variables

		arr[i++] = expanded;
		current = current->next;
	}
	arr[i] = NULL;
	return arr;
}


signals.c

#include "minishell.h"

/**
 * @brief Handles SIGINT (Ctrl+C) in interactive mode.
 * Prints a new prompt and resets input buffer.
 * @param sig Signal number (unused).
 */
void handle_sigint(int sig)
{
	(void)sig;
	write(STDOUT_FILENO, "\n", 1);
	rl_replace_line("", 0); // Reset readline buffer
	rl_on_new_line();
	rl_redisplay();
	set_exit_status(130); // Set $? to 130 (SIGINT code)
}

/*
** Sets up signal handlers for parent process (shell)
*/
void setup_parent_signals(void)
{
	struct sigaction sa;

	sa.sa_handler = handle_sigint; // Custom SIGINT handler
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sigaction(SIGINT, &sa, NULL);

	sa.sa_handler = SIG_IGN; // Ignore SIGQUIT in parent
	sigaction(SIGQUIT, &sa, NULL);
}

/**
 * @brief Configures child processes to use default signal handlers.
 * SIGINT and SIGQUIT will terminate children normally.
 */
void setup_child_signals(void)
{
	struct sigaction sa_default;

	sa_default.sa_handler = SIG_DFL;
	sigemptyset(&sa_default.sa_mask);
	sa_default.sa_flags = 0;

	// Reset to default signals
	signal(SIGINT, SIG_DFL);
	signal(SIGQUIT, SIG_DFL);
}


utils.c

#include "minishell.h"

/*
** Frees an array of strings
** @param args Array to free
*/
void ft_free_array(char **args)
{
	int i;

	if (!args)
		return;
	i = -1;
	while (args[++i])
		free(args[i]);
	free(args);
}

/*
** Checks if character is whitespace
** @param c Character to check
** @return 1 if whitespace, 0 otherwise
*/
int ft_isspace(int c)
{
	return (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\f' || c == '\v');
}

/*
** Advances to next character in parser input
** @param p Parser structure
*/
void next_char(t_parse *p)
{
	if (p->input[p->pos])
	{
		p->pos++;
		p->curr_char = p->input[p->pos];
	}
	else
	{
		p->curr_char = '\0';
	}
}

/*
** Checks if character is special shell character
** @param c Character to check
** @return 1 if special, 0 otherwise
*/
int is_special_char(char c)
{
	return (c == '|' || c == '>' || c == '<');
}

/*
** Converts a linked list to string array
** @param lst Linked list to convert
** @return New allocated string array
*/
char **list_to_array(t_list *lst)
{
	char **arr;
	int count;
	int i;
	t_list *tmp;

	count = ft_lstsize(lst);
	arr = malloc((count + 1) * sizeof(char *));
	if (!arr)
		return (NULL);

	i = 0;
	tmp = lst;
	while (tmp)
	{
		arr[i] = ft_strdup((char *)tmp->content);
		if (!arr[i])
		{
			ft_free_array(arr);
			return (NULL);
		}
		tmp = tmp->next;
		i++;
	}
	arr[i] = NULL;
	return (arr);
}

/*
** Frees a command structure
** @param cmd Command to free
*/
void free_cmd(t_cmd *cmd)
{
	t_redir *redir;
	t_redir *tmp;

	if (!cmd)
		return;

	// Free arguments
	ft_free_array(cmd->args);

	// Free redirections
	redir = cmd->redirections;
	while (redir)
	{
		tmp = redir->next;
		free(redir->filename);
		free(redir);
		redir = tmp;
	}
	free(cmd);
}

/*
** String comparison
** @param s1 First string
** @param s2 Second string
** @return Difference between first differing characters
*/
int ft_strcmp(const char *s1, const char *s2)
{
	while (*s1 && *s1 == *s2)
	{
		s1++;
		s2++;
	}
	return (*(unsigned char *)s1 - *(unsigned char *)s2);
}

/*
** Checks if string is numeric
** @param str String to check
** @return 1 if numeric, 0 otherwise
*/
int ft_isnumber(const char *str)
{
	int i;

	if (!str || !*str) // Handle NULL or empty string
		return (0);
	i = 0;
	// Allow optional leading +/-
	if (str[i] == '+' || str[i] == '-')
		i++;
	// Check remaining characters are digits
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return (0);
		i++;
	}
	// Must have at least one digit (after optional sign)
	return (i > 0 && (str[0] == '+' || str[0] == '-') ? i > 1 : i > 0);
}

/*
** Checks if string is valid variable name
** @param name String to check
** @return 1 if valid, 0 otherwise
*/
int is_valid_var_name(const char *name)
{
	int i;

	if (!name || !name[0] || ft_isdigit(name[0]))
		return (0);

	i = 0;
	while (name[i])
	{
		if (!ft_isalnum(name[i]) && name[i] != '_')
			return (0);
		i++;
	}
	return (1);
}

/*
** Prints environment variables in export format
*/
void print_export_declarations(void)
{
	extern char **environ;
	int i = 0;

	while (environ[i])
	{
		char *eq = ft_strchr(environ[i], '=');
		if (eq)
		{
			*eq = '\0';
			printf("declare -x %s=\"%s\"\n", environ[i], eq + 1);
			*eq = '=';
		}
		else
			printf("declare -x %s\n", environ[i]);
		i++;
	}
}

/*
** Safe strlen that returns size_t
** @param str String to measure
** @return Length of string
*/
size_t ft_strlen_size(const char *str)
{
	size_t len = 0;
	while (str[len])
		len++;
	return (len);
}

/*
** Joins three strings together
** @param s1 First string
** @param s2 Second string
** @param s3 Third string
** @return New concatenated string
*/
char *ft_strjoin3(const char *s1, const char *s2, const char *s3)
{
	char *tmp = ft_strjoin(s1, s2);
	char *result = ft_strjoin(tmp, s3);
	free(tmp);
	return result;
}

/**
 * @brief Appends an element to a NULL-terminated string array.
 * @param array Original array (freed after operation).
 * @param new_element Element to add.
 * @return New array with added element.
 */
char **ft_array_append(char **array, char *new_element)
{
	int count = 0;
	while (array && array[count])
		count++;

	char **new_array = malloc(sizeof(char *) * (count + 2));
	if (!new_array)
		return NULL;

	int i = -1;
	while (++i < count)
		new_array[i] = array[i];
	new_array[count] = new_element;
	new_array[count + 1] = NULL;

	free(array);
	return new_array;
}

/**
 * @brief Frees a t_arg structure and its contents.
 *
 * @param arg_ptr Pointer to a t_arg structure.
 */
void free_arg(void *arg)
{
	t_arg *a = (t_arg *)arg;
	free(a->value);
	free(a);
}

/**
 * @brief Concatenates two strings and frees the first string.
 *
 * @param s1 First string (will be freed). Can be NULL.
 * @param s2 Second string (not freed). Can be NULL.
 * @return char* New string containing `s1` + `s2`. NULL on allocation failure.
 */
char *ft_strjoin_free(char *s1, const char *s2)
{
	char *result = ft_strjoin(s1, s2);
	free(s1);
	return result;
}

/**
 * @brief Safely appends a character to a string.
 * @param str Original string (freed after appending).
 * @param c Character to append.
 * @return New allocated string with appended character.
 */
char *ft_strjoin_char(char *str, char c)
{
	char *new_str;
	size_t len;

	if (!str)
		len = 0;
	else
		len = ft_strlen(str);

	new_str = malloc(len + 2); // Existing chars + new char + null terminator
	if (!new_str)
		return (NULL);

	if (str)
		ft_memcpy(new_str, str, len);
	new_str[len] = c;
	new_str[len + 1] = '\0';

	free(str);
	return (new_str);
}

/**
 * @brief Counts the number of commands in a pipeline.
 *
 * @param pipeline Head of the command pipeline (linked list of t_cmd).
 * @return size_t Number of commands in the pipeline. Returns 0 if pipeline is NULL.
 *
 * @note Traverses the linked list of commands until reaching NULL.
 */
size_t ft_cmd_size(t_cmd *pipeline)
{
	size_t count = 0;
	while (pipeline)
	{
		count++;
		pipeline = pipeline->next;
	}
	return (count);
}

void free_redirections(t_redir *redirs)
{
	t_redir *tmp;
	while (redirs)
	{
		tmp = redirs->next;
		free(redirs->filename);
		free(redirs);
		redirs = tmp;
	}
}
