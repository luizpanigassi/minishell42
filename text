header

#ifndef MINISHELL_H
# define MINISHELL_H

# include "../libft/libft.h"

# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>
# include <string.h>
# include <sys/types.h>
# include <sys/wait.h>
# include <errno.h>
# include <signal.h>
# include <readline/readline.h>
# include <readline/history.h>
# include <dirent.h>
# include <limits.h>

# define CMD_NOT_FOUND 127
# define PERM_DENIED 126
# define SYNTAX_ERROR 2
# define EXIT_CODE_EXIT 4242

// Parsing structure
typedef enum e_token
{
	T_WORD,
	T_SINGLE_QUOTED,
	T_DOUBLE_QUOTED,
	T_PIPE,
	T_REDIR_OUT,
	T_REDIR_IN,
	T_APPEND,
	T_HEREDOC,
	T_EOF,
	T_SEMICOLON
}	t_token;

typedef struct s_parse
{
	char	*input;
	int		pos;
	char	curr_char;
	t_token	token_type;
	char	*token_value;
	int		redir_fd;
	int		syntax_error;
}	t_parse;

typedef struct s_redir {
	t_token			type;
	char			*filename;
	struct s_redir	*next;
	int				heredoc_quoted;
	int				fd;
}	t_redir;

typedef struct s_cmd {
	char			**args;
	t_redir			*redirections;
	struct s_cmd	*next;
}	t_cmd;

typedef struct s_arg {
	char	*value;
	t_token	type;
}	t_arg;

typedef struct s_export_params {
	int		*ret;
	int		*i;
	char	*arg;
}	t_export_params;

typedef struct s_exec_vars {
	int		prev_pipe[2];
	int		next_pipe[2];
	pid_t	*child_pids;
	pid_t	pid;
	t_cmd	*current;
	int		last_status;
}	t_exec_vars;

/*
** Global variable to store the exit status of commands
** volatile sig_atomic_t ensures safe access in signal handlers
*/
extern volatile sig_atomic_t	g_exit_status;

// INPUT
void	handle_error(char *message);
char	*get_cmd_path(char *cmd);
char	*expand_variables(const char *input);
void	exec_external_command(t_cmd *cmd);

// BUILTIN
int		is_builtin(char **args);
int		exec_cd(char **args);
int		exec_exit(char **args);
int		exec_echo(char **args);
int		exec_builtin(char **args);
int		exec_env(char **args);
int		exec_pwd(char **args);
int		exec_export(char **args);
int		exec_unset(char **args);
char	**ft_copy_env(char **env);
void	update_env_var(char *var, char *value);
void	ensure_var_exported(char *var_name);
char	**build_expanded_args(t_list *args);

// SIGNALS
void	handle_sigint(int sig);
void	setup_parent_signals(void);
void	setup_child_signals(void);
void	setup_heredoc_signals(void);

// PARSING
void	init_parser(t_parse *p, char *input);
void	next_token(t_parse *p);
t_cmd	*parse_args(t_parse *p);
int		create_heredoc(const char *delimiter);
int		is_redirection(t_token type);
t_cmd	*parse_pipeline(t_parse *p);
void	handle_special(t_parse *p);

// UTILS
void	ft_free_array(char **array);
void	free_cmd(t_cmd *cmd);
int		ft_strcmp(const char *s1, const char *s2);
char	**ft_array_append(char **array, char *new_element);
int		ft_isnumber(const char *str);
int		is_valid_var_name(const char *name);
void	print_export_declarations(void);
size_t	ft_strlen_size(const char *s);
char	**ft_array_append(char **array, char *new_element);
char	*ft_strjoin3(const char *s1, const char *s2, const char *s3);
void	free_arg(void *arg);
char	*ft_strjoin_free(char *s1, const char *s2);
char	*ft_strjoin_char(char *str, char c);
size_t	ft_cmd_size(t_cmd *pipeline);
void	free_redirections(t_redir *redirs);
void	free_env_copy(char **env_copy);
void	syntax_error(char *token);
char	*parse_fd(t_parse *p);
char	**split_with_quotes(const char *str, char delim);
void	update_quote_state(char c, int *in_quote, char *quote_char);
void	add_substring(char ***result, int *count,
			const char *start, const char *end);

// Helper functions for parsing
int		ft_isspace(int c);
void	next_char(t_parse *p);
int		is_special_char(char c);
char	**list_to_array(t_list *lst);
int		handle_redirections(int pipe_in, int pipe_out, t_redir *redirections);

//Exit status
void	set_exit_status(int status);
int		get_exit_status(void);

int		handle_cd_arguments(char **args, char *oldpwd);
int		handle_export_argument(char *arg, int *i, int *ret);
int		handle_invalid_identifier(char *var_name, char *value,
			t_export_params params);

int		execute_pipeline(t_cmd *pipeline);
void	free_pipeline(t_cmd *pipeline);

#endif

builtin.c

#include "minishell.h"

extern volatile sig_atomic_t g_exit_status;

/*
** Checks if a command is a builtin
** @param tokens Array of command tokens
** @return 1 if builtin, 0 otherwise
*/
int is_builtin(char **tokens)
{
	const char *builtins[] = {"echo", "cd", "pwd", "export",
							  "unset", "env", "exit", NULL};
	int i;

	if (!tokens || !tokens[0])
		return (0);
	i = 0;
	while (builtins[i])
	{
		if (ft_strcmp(tokens[0], builtins[i]) == 0)
			return (1);
		i++;
	}
	return (0);
}

/*
** Executes the appropriate builtin function based on command
** @param args Command arguments
** @return Exit status of the builtin command
*/
int exec_builtin(char **args)
{
	if (ft_strcmp(args[0], "echo") == 0)
		return (exec_echo(args));
	if (ft_strcmp(args[0], "cd") == 0)
		return (exec_cd(args));
	if (ft_strcmp(args[0], "pwd") == 0)
		return (exec_pwd(args));
	if (ft_strcmp(args[0], "export") == 0)
		return (exec_export(args));
	if (ft_strcmp(args[0], "unset") == 0)
		return (exec_unset(args));
	if (ft_strcmp(args[0], "env") == 0)
		return (exec_env(args));
	if (ft_strcmp(args[0], "exit") == 0)
	{
		exec_exit(args);
		return (EXIT_CODE_EXIT);
	}
	return (0);
}

/*
** Creates a copy of the environment variables array
** @param original Original environment array
** @return New allocated copy of the environment
*/
char **ft_copy_env(char **original)
{
	char **copy;
	int i;
	int count;

	i = 0;
	if (!original)
		return NULL;

	count = 0;
	while (original[count])
		count++;

	copy = malloc(sizeof(char *) * (count + 1));
	if (!copy)
		return NULL;
	while (i < count)
	{
		copy[i] = ft_strdup(original[i]);
		if (!copy[i])
		{
			ft_free_array(copy);
			return NULL;
		}
		i++;
	}
	copy[count] = NULL;
	return copy;
}

/* Environment variable operations */
/**
 * @brief Updates or adds an environment variable.
 * @param var Variable name (ownership transferred).
 * @param value Variable value (ownership transferred).
 */
void update_env_var(char *var, char *value)
{
	extern char **environ;
	char *new_entry;
	char *eq;
	char **env_ptr;

	new_entry = value ? ft_strjoin3(var, "=", value) : ft_strjoin(var, "=");
	env_ptr = environ;

	while (*env_ptr)
	{
		eq = ft_strchr(*env_ptr, '=');
		if (eq && ft_strncmp(*env_ptr, var, eq - *env_ptr) == 0)
		{
			free(*env_ptr);
			*env_ptr = new_entry;
			return;
		}
		env_ptr++;
	}

	environ = ft_array_append(environ, new_entry);
	free(var);
	if (value)
		free(value);
}

/*
** Ensures a variable exists in the environment (without value if not present)
** @param var_name Variable name to check/export
*/
void ensure_var_exported(char *var_name)
{
	extern char **environ;
	char **env_ptr;
	int exists;
	char *eq;

	exists = 0;
	env_ptr = environ;
	while (*env_ptr && !exists)
	{
		eq = ft_strchr(*env_ptr, '=');
		if (eq && ft_strncmp(*env_ptr, var_name, eq - *env_ptr) == 0)
			exists = 1;
		env_ptr++;
	}
	if (!exists)
		update_env_var(var_name, NULL);
	else
		free(var_name);
}

exec_cd.c

#include "minishell.h"

/*
** Changes the current directory
** @param args Command arguments (args[1] is the target directory)
** @return 0 on success, 1 on failure
*/
int	exec_cd(char **args)
{
	char	*oldpwd;
	char	*newpwd;

	oldpwd = getcwd(NULL, 0);
	if (!oldpwd)
		return (perror("cd"), 1);
	if (handle_cd_arguments(args, oldpwd) != 0)
		return (1);
	newpwd = getcwd(NULL, 0);
	if (!newpwd)
	{
		free(oldpwd);
		return (perror("cd"), 1);
	}
	update_env_var("OLDPWD", oldpwd);
	free(oldpwd);
	update_env_var("PWD", newpwd);
	free(newpwd);
	return (0);
}

int	handle_cd_arguments(char **args, char *oldpwd)
{
	char	*path;

	if (args[1] && args[2])
	{
		ft_putstr_fd("minishell: cd: too many arguments\n", STDERR_FILENO);
		free(oldpwd);
		set_exit_status(1);
		return (1);
	}
	if (!args[1] || ft_strcmp(args[1], "~") == 0)
	{
		path = getenv("HOME");
		if (!path)
		{
			ft_putstr_fd("minishell: cd: HOME not set\n", STDERR_FILENO);
			free(oldpwd);
			return (1);
		}
	}
	else if (ft_strcmp(args[1], "-") == 0)
	{
		path = getenv("OLDPWD");
		if (!path)
		{
			ft_putstr_fd("minishell: cd: OLDPWD not set\n", STDERR_FILENO);
			free(oldpwd);
			return (1);
		}
	}
	else
		path = args[1];
	if (chdir(path) != 0)
	{
		perror("cd");
		set_exit_status(1);
		free(oldpwd);
		return (1);
	}
	return (0);
}

exec_echo.c

#include "minishell.h"

/*
** Prints arguments to stdout with optional newline suppression
** @param args Command arguments (-n flag suppresses newline)
** @return Always returns 0
*/
int	exec_echo(char **args)
{
	int	i;
	int	nl_flag;

	i = 1;
	nl_flag = 0;
	if (args[1] && ft_strcmp(args[1], "-n") == 0)
	{
		nl_flag = 1;
		i++;
	}
	while (args[i])
	{
		ft_putstr_fd(args[i], STDOUT_FILENO);
		if (args[++i])
			ft_putchar_fd(' ', STDOUT_FILENO);
	}
	if (!nl_flag)
		ft_putchar_fd('\n', STDOUT_FILENO);
	return (0);
}

exec_env.c

#include "minishell.h"

/*
** Prints the current environment variables
** @param args Ignored
** @return Always returns 0
*/
int	exec_env(char **args)
{
	extern char	**environ;
	int			i;

	(void)args;
	i = -1;
	while (environ[++i])
		printf("%s\n", environ[i]);
	return (0);
}

exec_exit.c

#include "minishell.h"

/*
** Exits the shell with optional status code
** @param args Command arguments (args[1] is optional exit status)
** @return Does not return on success, returns 1 if too many arguments
*/
int	exec_exit(char **args)
{
	int	status;

	status = 0;
	if (args[1] && args[2])
	{
		ft_putstr_fd("minishell: exit error: too many arguments\n",
			STDERR_FILENO);
		set_exit_status(1);
		return (1);
	}
	if (args[1])
	{
		if (ft_isnumber(args[1]))
			status = ft_atoi(args[1]) % 256;
		else
		{
			ft_putstr_fd("minishell: exit error: numeric argument required\n",
				STDERR_FILENO);
			return (2);
		}
	}
	printf("Exiting minishell, goodbye!\n");
	rl_clear_history();
	exit(status);
}

exec_export.c

#include "minishell.h"

/**
 * @brief Executes the 'export' builtin to set environment variables.
 * @param args Array of arguments (e.g., ["export", "VAR=value"]).
 * @return 0 on success, 1 if any invalid variable name is encountered.
 */
int	exec_export(char **args)
{
	int	ret;
	int	i;

	if (!args[1])
		return (print_export_declarations(), 0);
	ret = 0;
	i = 1;
	while (args[i])
	{
		if (handle_export_argument(args[i], &i, &ret))
			continue ;
		i++;
	}
	return (ret);
}

int	handle_invalid_identifier(char *var_name, char *value,
		t_export_params params)
{
	if (is_valid_var_name(var_name))
		return (0);
	ft_putstr_fd("minishell: export: '", STDERR_FILENO);
	ft_putstr_fd(params.arg, STDERR_FILENO);
	ft_putstr_fd("': not a valid identifier\n", STDERR_FILENO);
	*params.ret = 1;
	free(var_name);
	free(value);
	(*params.i)++;
	return (1);
}

int	handle_export_argument(char *arg, int *i, int *ret)
{
	char			*eq_pos;
	char			*var_name;
	char			*value;
	t_export_params	params;

	params = (t_export_params){ret, i, arg};
	eq_pos = ft_strchr(arg, '=');
	var_name = NULL;
	value = NULL;
	if (eq_pos)
	{
		var_name = ft_substr(arg, 0, eq_pos - arg);
		value = ft_strdup(eq_pos + 1);
	}
	else
		var_name = ft_strdup(arg);
	if (handle_invalid_identifier(var_name, value, params))
		return (1);
	if (eq_pos)
		update_env_var(var_name, value);
	else
		ensure_var_exported(var_name);
	return (0);
}

exec_pwd.c

#include "minishell.h"

/*
** Prints the current working directory
** @param args Ignored
** @return 0 on success, 1 on failure
*/
int	exec_pwd(char **args)
{
	char	*cwd;

	(void)args;
	cwd = getcwd(NULL, 0);
	if (args[1])
	{
		ft_putstr_fd("minishell: pwd: too many arguments\n", STDERR_FILENO);
		free(cwd);
		return (1);
	}
	if (cwd && args[1] == NULL)
	{
		printf("%s\n", cwd);
		free(cwd);
		return (0);
	}
	else
	{
		perror("minishell: pwd");
		return (1);
	}
}

exec_unset.c

#include "minishell.h"

static int	handle_unset_error(char *arg)
{
	if (is_valid_var_name(arg))
		return (0);
	ft_putstr_fd("minishell: unset: '", STDERR_FILENO);
	ft_putstr_fd(arg, STDERR_FILENO);
	ft_putstr_fd("': not a valid identifier\n", STDERR_FILENO);
	return (1);
}

static void	shift_environment(char **env_ptr)
{
	char	**ptr;

	ptr = env_ptr;
	while (*ptr)
	{
		*ptr = *(ptr + 1);
		ptr++;
	}
}

static void	remove_env_var(const char *var_name)
{
	extern char	**environ;
	char		**env_ptr;
	char		*eq;
	size_t		var_len;
	size_t		name_len;

	env_ptr = environ;
	name_len = ft_strlen(var_name);
	while (*env_ptr)
	{
		eq = ft_strchr(*env_ptr, '=');
		if (eq)
			var_len = eq - *env_ptr;
		else
			var_len = ft_strlen(*env_ptr);
		if (var_len == name_len && ft_strncmp(*env_ptr, var_name, var_len) == 0)
		{
			free(*env_ptr);
			shift_environment(env_ptr);
			break ;
		}
		env_ptr++;
	}
}

/**
 * @brief Executes the 'unset' builtin to remove environment variables.
 * @param args Array of arguments (e.g., ["unset", "VAR"]).
 * @return 0 on success, 1 if any invalid variable name is encountered.
 */
int	exec_unset(char **args)
{
	int	ret;
	int	i;

	if (!args[1])
		return (0);
	ret = 0;
	i = 1;
	while (args[i])
	{
		if (handle_unset_error(args[i]))
			ret = 1;
		else
			remove_env_var(args[i]);
		i++;
	}
	return (ret);
}

create_heredoc.c

#include <minishell.h>

/**
 * @brief Creates a temporary heredoc file.
 * @param delimiter Heredoc termination string.
 * @return File descriptor of the heredoc temp file.
 * @note Automatically deletes the temp file after opening.
 */
int create_heredoc(const char *delimiter)
{
	int pipefd[2];
	pid_t pid;
	int status;
	char *line;
	int quoted_delimiter;
	char *expanded;

	if (pipe(pipefd) < 0)
		return (-1);
	pid = fork();
	if (pid == -1)
	{
		close(pipefd[0]);
		close(pipefd[1]);
		return (-1);
	}
	if (pid == 0) // Child process
	{
		close(pipefd[0]);
		signal(SIGINT, SIG_DFL);
		signal(SIGQUIT, SIG_IGN);
		quoted_delimiter = (delimiter[0] == '\'' || delimiter[0] == '"');
		while (1)
		{
			line = readline("> ");
			if (!line) // Handle Ctrl+D
			{
				write(STDOUT_FILENO, "\n", 1);
				break;
			}
			if (strcmp(line, delimiter) == 0) // End of heredoc
			{
				free(line);
				break;
			}
			if (!quoted_delimiter)
			{
				expanded = expand_variables(line);
				write(pipefd[1], expanded, strlen(expanded));
				free(expanded);
			}
			else
				write(pipefd[1], line, strlen(line));
			write(pipefd[1], "\n", 1);
			free(line);
		}
		close(pipefd[1]); // Close write end in child
		exit(0);
	}
	else // Parent process
	{
		close(pipefd[1]);
		waitpid(pid, &status, 0);
		if (WIFSIGNALED(status) && WTERMSIG(status) == SIGINT)
		{
			close(pipefd[0]);
			return (-1); // Return error if interrupted
		}
		return (pipefd[0]);
	}
}

exit_status.c

#include "minishell.h"

/**
 * @brief Updates the global exit status variable.
 * @param status Exit code to store (0-255).
 */
void	set_exit_status(int status)
{
	g_exit_status = status;
}

/**
 * @brief Retrieves the global exit status.
 * @return Last exit status of foreground commands.
 */
int	get_exit_status(void)
{
	return (g_exit_status);
}

get_cmd_path.c

#include "minishell.h"

static char	*check_path_for_cmd(const char *dir_path, const char *cmd)
{
	char	*dir_slash;
	char	*full_path;

	dir_slash = ft_strjoin(dir_path, "/");
	if (!dir_slash)
		return (NULL);
	full_path = ft_strjoin(dir_slash, cmd);
	free(dir_slash);
	if (!full_path)
		return (NULL);
	if (access(full_path, X_OK) == 0)
		return (full_path);
	free(full_path);
	return (NULL);
}

static char	**get_path_directories(void)
{
	char	*path_env;
	char	**paths;

	path_env = getenv("PATH");
	if (!path_env)
		return (NULL);
	paths = ft_split(path_env, ':');
	if (!paths)
		return (NULL);
	return (paths);
}

static char	*check_direct_path(char *cmd)
{
	if (ft_strchr(cmd, '/') != NULL)
	{
		if (access(cmd, F_OK) == -1)
			return (NULL);
		if (access(cmd, X_OK) == -1)
		{
			g_exit_status = PERM_DENIED;
			return (NULL);
		}
		return (ft_strdup(cmd));
	}
	return (NULL);
}

/**
 * @brief Locates the full path of a command using PATH.
 * @param cmd Command name (e.g., "ls").
 * @return Allocated full path (e.g., "/bin/ls") or NULL if not found.
 * Caller must free the returned string.
 */
char	*get_cmd_path(char *cmd)
{
	char	**paths;
	char	*full_path;
	int		i;

	full_path = check_direct_path(cmd);
	if (full_path)
		return (full_path);
	paths = get_path_directories();
	if (!paths)
		return (NULL);
	i = 0;
	while (paths[i])
	{
		full_path = check_path_for_cmd(paths[i], cmd);
		if (full_path)
		{
			ft_free_array(paths);
			return (full_path);
		}
		i++;
	}
	ft_free_array(paths);
	return (NULL);
}

handle_pipe.c

#include "minishell.h"

/*
** Executes a pipeline of commands with proper piping
** @param pipeline Command pipeline to execute
** @return Exit status of the last command in pipeline
*/
int execute_pipeline(t_cmd *pipeline)
{
	int prev_pipe[2] = {-1, -1};
	int next_pipe[2] = {-1, -1};
	pid_t *child_pids;
	int cmd_count = ft_cmd_size(pipeline);
	int i = 0;

	if (cmd_count == 0)
		return 1;
	child_pids = malloc(sizeof(pid_t) * cmd_count);
	if (!child_pids)
		return 1;

	t_cmd *current = pipeline;
	while (current)
	{
		t_redir *r = current->redirections;
		while (r)
		{
			if (r->type == T_HEREDOC)
			{
				int hd_fd = create_heredoc(r->filename);
				if (hd_fd < 0)
				{ // Heredoc was interrupted
					free(child_pids);
					free_pipeline(pipeline);
					return 130;
				}
				r->fd = hd_fd;
			}
			r = r->next;
		}
		if (current->next && pipe(next_pipe) < 0)
		{
			perror("minishell: pipe");
			free(child_pids);
			return 1;
		}

		pid_t pid = fork();
		if (pid == 0) // Child
		{
			setup_child_signals();
			// pipe redirections
			int pipe_out = -1;
			if (current->next)
				pipe_out = next_pipe[1];
			handle_redirections(prev_pipe[0], pipe_out, current->redirections);
			if (prev_pipe[0] != -1)
				close(prev_pipe[0]);
			if (prev_pipe[1] != -1)
				close(prev_pipe[1]);
			if (next_pipe[0] != -1)
				close(next_pipe[0]);
			if (next_pipe[1] != -1)
				close(next_pipe[1]);

			if (is_builtin(current->args))
				exit(exec_builtin(current->args));
			else
				exec_external_command(current);
		}
		else if (pid > 0) // Parent
		{
			child_pids[i++] = pid;
			if (prev_pipe[0] != -1)
				close(prev_pipe[0]);
			if (prev_pipe[1] != -1)
				close(prev_pipe[1]);
			// Move to next pipe
			prev_pipe[0] = next_pipe[0];
			prev_pipe[1] = next_pipe[1];
			next_pipe[0] = -1;
			next_pipe[1] = -1;
		}
		else // Fork failed
		{
			perror("minishell: fork");
			free(child_pids);
			return 1;
		}
		current = current->next;
	}
	if (prev_pipe[0] != -1)
		close(prev_pipe[0]);
	if (prev_pipe[1] != -1)
		close(prev_pipe[1]);

	// Wait for all children with EINTR handling
	int last_status = 0;
	int child_count = 0;
	while (child_count < cmd_count)
	{
		int status;
		waitpid(child_pids[child_count], &status, 0);
		if (WIFEXITED(status))
			last_status = WEXITSTATUS(status);
		else if (WIFSIGNALED(status))
			last_status = 128 + WTERMSIG(status);
		child_count++;
	}
	t_cmd *last_cmd = pipeline;
	while (last_cmd->next)
		last_cmd = last_cmd->next;

	if (is_builtin(last_cmd->args) && ft_strcmp(last_cmd->args[0], "exit") == 0)
	{
		free(child_pids);
		free_pipeline(pipeline);
		exit(last_status);
	}

	free(child_pids);
	set_exit_status(last_status);
	return last_status;
}

handle_special.c

#include "minishell.h"

static void	assign_value(t_parse *p, enum e_token t, char *v, int n)
{
	p->token_type = t;
	p->token_value = ft_strdup(v);
	if (n)
		next_char(p);
}

static void	handle_file_descriptor(t_parse *p)
{
	int		fd;
	char	*fd_str;

	fd = 0;
	if (ft_isdigit(p->curr_char))
	{
		fd_str = parse_fd(p);
		fd = ft_atoi(fd_str);
		free(fd_str);
		p->redir_fd = fd;
	}
}

static void	handle_output_redirection(t_parse *p)
{
	next_char(p);
	if (p->curr_char == '>')
		assign_value(p, T_APPEND, ">>", 1);
	else
		assign_value(p, T_REDIR_OUT, ">", 0);
}

static void	handle_input_redirection(t_parse *p)
{
	next_char(p);
	if (p->curr_char == '<')
		assign_value(p, T_HEREDOC, "<<", 1);
	else
		assign_value(p, T_REDIR_IN, "<", 0);
}

void	handle_special(t_parse *p)
{
	handle_file_descriptor(p);
	if (p->curr_char == '|')
		assign_value(p, T_PIPE, "|", 1);
	else if (p->curr_char == '>')
		handle_output_redirection(p);
	else if (p->curr_char == '<')
		handle_input_redirection(p);
}

init_parser.c

#include <minishell.h>

/**
 * @brief Initializes the parser state for new input.
 * @param p Parser structure to initialize.
 * @param input Input string to parse.
 */
void	init_parser(t_parse *p, char *input)
{
	p->input = input;
	p->pos = 0;
	p->curr_char = input[0];
	p->token_type = T_EOF;
	p->token_value = NULL;
	p->redir_fd = 0;
	p->syntax_error = 0;
}

input.c

#include "minishell.h"

/*
** Prints error message and exits
** @param message Error message to display
*/
void	handle_error(char *message)
{
	perror(message);
	exit(EXIT_FAILURE);
}

/**
 * @brief Expands environment variables and `$?` in a string.
 *
 * @param input The input string to process.
 * @return char* New string with variables expanded. Must be freed by the caller.
 *
 * @note Expansion rules:
 * - `$VAR` → Replaced with environment variable value.
 * - `$?` → Replaced with the last exit status.
 * - Single-quoted strings suppress expansion.
 * - Double-quoted strings allow `$VAR` and `$?` expansion.
 */
static char	*expand_variable(const char *input, size_t *i)
{
	char	*value;
	size_t	start;
	char	*var_name;
	char	*var_value;

	if (input[*i] == '?')
	{
		value = ft_itoa(get_exit_status());
		(*i)++;
	}
	else
	{
		start = *i;
		while (input[*i] && (ft_isalnum(input[*i]) || input[*i] == '_'))
			(*i)++;
		var_name = ft_substr(input, start, *i - start);
		var_value = getenv(var_name);
		if (var_value)
			value = ft_strdup(var_value);
		else
			value = ft_strdup("");
		free(var_name);
	}
	return (value);
}

char	*expand_variables(const char *input)
{
	char	*result;
	size_t	i;
	char	*var_value;

	i = 0;
	result = ft_strdup("");
	while (input[i])
	{
		if (input[i] == '$' && (input[i + 1] == '?' || ft_isalpha(input[i + 1])
				|| input[i + 1] == '_'))
		{
			i++;
			if (input[i])
			{
				var_value = expand_variable(input, &i);
				result = ft_strjoin_free(result, var_value);
				free(var_value);
			}
		}
		else
			result = ft_strjoin_char(result, input[i++]);
	}
	return (result);
}

/**
 * @brief Executes an external command in a child process.
 * @param cmd Command structure with arguments and redirections.
 * @note Terminates the process on completion or error.
 */
void	exec_external_command(t_cmd *cmd)
{
	extern char	**environ;
	char		*path;

	path = get_cmd_path(cmd->args[0]);
	if (!path)
	{
		if (access(cmd->args[0], F_OK) == 0)
			exit(PERM_DENIED);
		ft_putstr_fd("minishell: ", STDERR_FILENO);
		ft_putstr_fd(cmd->args[0], STDERR_FILENO);
		ft_putstr_fd(": command not found\n", STDERR_FILENO);
		exit(CMD_NOT_FOUND);
	}
	execve(path, cmd->args, environ);
	perror("minishell");
	free(path);
	exit(EXIT_FAILURE);
}

/**
 * @brief Handles redirection for commands.
 * @param current Current redirection node.
 * @param fd File descriptor for redirection.
 * @return int 0 on success, -1 on error.
 */
int	handle_redirection(t_redir *current, int fd)
{
	if (current->type == T_REDIR_IN || current->type == T_HEREDOC)
	{
		if (dup2(fd, STDIN_FILENO) == -1)
		{
			close(fd);
			perror("minishell");
			return (-1);
		}
	}
	else
	{
		if (dup2(fd, STDOUT_FILENO) == -1)
		{
			close(fd);
			perror("minishell");
			return (-1);
		}
	}
	return (0);
}

main.c

#include "minishell.h"

volatile sig_atomic_t g_exit_status = 0;

/**
 * @brief Frees a command pipeline and associated resources.
 * @param pipeline Linked list of command structures.
 */
void free_pipeline(t_cmd *pipeline)
{
	t_cmd *current;
	t_redir *redir;
	t_redir *tmp_redir;

	while (pipeline)
	{
		current = pipeline;
		pipeline = pipeline->next;
		if (current->args)
			ft_free_array(current->args);
		redir = current->redirections;
		while (redir)
		{
			tmp_redir = redir;
			redir = redir->next;
			free(tmp_redir->filename);
			free(tmp_redir);
		}

		free(current);
	}
}

/**
 * @brief Executes a single command with I/O redirection.
 * @param cmd Command structure to execute.
 * @param pipe_in Input file descriptor (or -1).
 * @param pipe_out Output file descriptor (or -1).
 */
void execute_command(t_cmd *cmd, int pipe_in, int pipe_out)
{
	pid_t pid;
	extern char **environ;
	char *cmd_path;

	pid = fork();
	if (pid == 0)
	{
		setup_child_signals();
		handle_redirections(pipe_in, pipe_out, cmd->redirections);

		if (is_builtin(cmd->args))
		{
			exec_builtin(cmd->args);
			exit(g_exit_status);
		}
		else
		{
			cmd_path = get_cmd_path(cmd->args[0]);
			if (!cmd_path)
			{
				ft_putstr_fd("minishell: command not found: ", STDERR_FILENO);
				ft_putstr_fd(cmd->args[0], STDERR_FILENO);
				ft_putstr_fd("\n", STDERR_FILENO);
				exit(CMD_NOT_FOUND);
			}
			execve(cmd_path, cmd->args, environ);
			perror("minishell");
			free(cmd_path);
			exit(EXIT_FAILURE);
		}
	}
	else if (pid < 0)
	{
		perror("fork");
	}
}

/*
** Sets up file descriptors for I/O redirection
** @param pipe_in Input file descriptor
** @param pipe_out Output file descriptor
** @param redirections List of redirection specifications
** @return 0 on success, -1 on error
*/
int handle_redirections(int pipe_in, int pipe_out, t_redir *redirections)
{
	// Handle pipe redirections first
	if (pipe_in != -1)
	{
		if (dup2(pipe_in, STDIN_FILENO) == -1)
			return (perror("minishell"), -1);
		close(pipe_in);
	}
	if (pipe_out != -1)
	{
		if (dup2(pipe_out, STDOUT_FILENO) == -1)
			return (perror("minishell"), -1);
		close(pipe_out);
	}
	// Handle file redirections
	t_redir *current = redirections;
	while (current)
	{
		int fd = -1;
		if (current->type == T_HEREDOC)
			fd = current->fd;
		else if (current->type == T_REDIR_IN)
			fd = open(current->filename, O_RDONLY);
		else if (current->type == T_REDIR_OUT)
			fd = open(current->filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
		else if (current->type == T_APPEND)
			fd = open(current->filename, O_WRONLY | O_CREAT | O_APPEND, 0644);

		if (fd == -1)
		{
			perror("minishell");
			set_exit_status(1);
			exit(EXIT_FAILURE);
		}
		if (current->type == T_REDIR_IN || current->type == T_HEREDOC)
		{
			if (dup2(fd, STDIN_FILENO) == -1)
				return (close(fd), perror("minishell"), -1);
		}
		else
		{
			if (dup2(fd, STDOUT_FILENO) == -1)
				return (close(fd), perror("minishell"), -1);
		}
		close(fd);
		current = current->next;
	}
	return (0);
}

/*
** Main shell loop
** @return Exit status of shell
*/
int main(void)
{
	extern char **environ;
	char **env_copy;
	char **original_environ;
	char **initial_env_copy;
	char *input;

	original_environ = environ;
	env_copy = ft_copy_env(environ);
	initial_env_copy = env_copy;
	environ = env_copy;
	setup_parent_signals();
	while (1)
	{
		input = readline("minishell> ");
		if (!input) // Handle Ctrl+D
		{
			environ = original_environ;
			free_env_copy(env_copy);
			rl_clear_history();
			write(STDOUT_FILENO, "Exiting minishell, goodbye!\n", 28);
			return (get_exit_status());
		}

		if (ft_strlen(input) > 0)
			add_history(input);
		else
		{
			free(input);
			continue;
		}

		char **commands = split_with_quotes(input, ';');
		free(input);
		int syntax_error_flag = 0;
		int i = 0;

		while (commands && commands[i] && !syntax_error_flag)
		{
			char *trimmed_cmd = ft_strtrim(commands[i], " \t\n");

			// Check for empty command (e.g., ";" or " | ")
			if (!trimmed_cmd || *trimmed_cmd == '\0')
			{
				free(trimmed_cmd);
				i++;
				continue;
			}

			t_parse parser;
			init_parser(&parser, trimmed_cmd);
			t_cmd *pipeline = parse_pipeline(&parser);
			free(trimmed_cmd);

			if (parser.syntax_error)
			{
				// Handle parsing errors
				syntax_error_flag = 1;
				set_exit_status(SYNTAX_ERROR);
				free_pipeline(pipeline);
				pipeline = NULL;
				i++;
				continue;
			}

			// Handle builtins in parent
			if (!pipeline->next && is_builtin(pipeline->args))
			{
				int saved_stdin = dup(STDIN_FILENO);
				int saved_stdout = dup(STDOUT_FILENO);
				int saved_stderr = dup(STDERR_FILENO);

				if (handle_redirections(-1, -1, pipeline->redirections) != 0)
					set_exit_status(1);
				else
				{
					int result = exec_builtin(pipeline->args);
					set_exit_status(result);
					env_copy = environ;
					dup2(saved_stdin, STDIN_FILENO);
					dup2(saved_stdout, STDOUT_FILENO);
					dup2(saved_stderr, STDERR_FILENO);
				}
				close(saved_stdin);
				close(saved_stdout);
				close(saved_stderr);

				if (ft_strcmp(pipeline->args[0], "exit") == 0 && get_exit_status() != 1)
				{
					free_pipeline(pipeline);
					free_env_copy(env_copy);
					break; // Terminate shell
				}
			}
			else
			{
				execute_pipeline(pipeline);
			}

			free_pipeline(pipeline);
			i++;
		}
		if (commands)
		{
			char **ptr = commands;
			while (*ptr)
			{
				free(*ptr);
				ptr++;
			}
			free(commands);
		}

		if (syntax_error_flag)
			set_exit_status(SYNTAX_ERROR);

		setup_parent_signals();
	}
	free_env_copy(env_copy);
	if (initial_env_copy != env_copy)
		free_env_copy(initial_env_copy);
	environ = original_environ;
	rl_clear_history();
	return (get_exit_status());
}

parse_args.c

#include "minishell.h"

/* Process a single argument and add it to the args list */
static void process_argument(t_parse *p, t_list **args)
{
	t_arg *arg;

	arg = malloc(sizeof(t_arg));
	arg->value = ft_strdup(p->token_value);
	arg->type = p->token_type;
	ft_lstadd_back(args, ft_lstnew(arg));
}

/* Handle redirection errors and return appropriate error message */
static t_redir *handle_redir_error(t_parse *p, t_list **args, t_redir *redirs)
{
	ft_putstr_fd("minishell: syntax error near unexpected token `",
				 STDERR_FILENO);
	if (p->token_type == T_EOF)
		ft_putstr_fd("newline", STDERR_FILENO);
	else
		ft_putstr_fd(p->token_value, STDERR_FILENO);
	ft_putstr_fd("'\n", STDERR_FILENO);
	ft_lstclear(args, free_arg);
	free_redirections(redirs);
	p->syntax_error = 1;
	return (NULL);
}

/* Process a redirection and add it to the redirection list */
static t_redir *process_redirection(t_parse *p, t_list **args, t_redir *redirs)
{
	t_redir *redir;

	redir = malloc(sizeof(t_redir));
	if (!redir)
	{
		ft_lstclear(args, free_arg);
		free_redirections(redirs);
		return (NULL);
	}
	redir->fd = p->redir_fd;
	redir->type = p->token_type;
	next_token(p);
	if (!p->token_value || (p->token_type != T_WORD &&
							p->token_type != T_SINGLE_QUOTED && p->token_type != T_DOUBLE_QUOTED))
	{
		free(redir);
		return (handle_redir_error(p, args, redirs));
	}
	p->redir_fd = 0;
	redir->filename = ft_strdup(p->token_value);
	redir->next = NULL;
	return (redir);
}

/* Create the final command structure */
static t_cmd *create_command(t_list *args, t_redir *redirs)
{
	t_cmd *cmd;

	cmd = malloc(sizeof(t_cmd));
	if (!cmd)
	{
		ft_lstclear(&args, free_arg);
		free_redirections(redirs);
		return (NULL);
	}
	cmd->args = build_expanded_args(args);
	cmd->redirections = redirs;
	cmd->next = NULL;
	ft_lstclear(&args, free_arg);
	return (cmd);
}

/* Main parse_args function, now using helper functions */
t_cmd *parse_args(t_parse *p)
{
	t_list *args;
	t_redir *redirs;
	t_redir **redir_tail;
	t_redir *new_redir;

	args = NULL;
	redirs = NULL;
	redir_tail = &redirs;
	while (p->token_type != T_EOF && p->token_type != T_PIPE && p->token_type != T_SEMICOLON)
	{
		if (p->token_type == T_WORD || p->token_type == T_SINGLE_QUOTED || p->token_type == T_DOUBLE_QUOTED)
		{
			if (!p->token_value)
			{
				ft_lstclear(&args, free_arg);
				free_redirections(redirs);
				return NULL;
			}
			process_argument(p, &args);
		}
		else if (is_redirection(p->token_type))
		{
			new_redir = process_redirection(p, &args, redirs);
			if (!new_redir)
				return (NULL);
			*redir_tail = new_redir;
			redir_tail = &new_redir->next;
		}
		next_token(p);
	}
	return (create_command(args, redirs));
}

parse_pipeline.c

#include "minishell.h"

t_cmd *parse_pipeline(t_parse *p)
{
	t_cmd *head;
	t_cmd **curr;
	t_cmd *cmd;
	char *error_token;

	head = NULL;
	curr = &head;
	next_token(p);

	// empty input or immediate pipe
	if (p->token_type == T_PIPE || p->token_type == T_SEMICOLON)
	{
		syntax_error(p->token_value ? p->token_value : "newline");
		return NULL;
	}
	while (1)
	{
		cmd = parse_args(p);
		// parse_args failed
		if (p->syntax_error)
		{
			free_cmd(head);
			return NULL;
		}
		// valid command
		if (cmd)
		{
			*curr = cmd;
			curr = &cmd->next;
		}
		// pipeline termination conditions
		if (!cmd || p->token_type != T_PIPE)
			break;
		next_token(p);
		// consecutive pipes
		error_token = p->token_value;
		if (p->token_type == T_EOF)
			error_token = "newline";
		else if (p->token_type == T_PIPE || p->token_type == T_SEMICOLON)
			error_token = p->token_value;
		if (p->token_type == T_PIPE || p->token_type == T_SEMICOLON || p->token_type == T_EOF)
		{
			syntax_error(error_token);
			free_cmd(head);
			return NULL;
		}
	}
	// syntax check after pipeline parsing
	if (p->syntax_error)
	{
		free_cmd(head);
		return NULL;
	}
	return head;
}

parser.c

#include "minishell.h"

/*
** Skips whitespace characters in input
** @param p Parser structure
*/
static void	skip_whitespace(t_parse *p)
{
	while (ft_isspace(p->curr_char))
		next_char(p);
}

/*
** Handles quoted strings in input
** @param p Parser structure
** @param quote Type of quote (' or ")
*/
static void	handle_quotes(t_parse *p, char quote)
{
	size_t	start;
	char	*content;

	start = p->pos;
	next_char(p);
	while (p->curr_char && (p->curr_char != quote
			|| (p->input[p->pos - 1] == '\\')))
	{
		if (p->curr_char == '\\' && quote == '"')
			next_char(p);
		next_char(p);
	}
	if (!p->curr_char)
	{
		ft_putstr_fd("minishell: unmatched quote\n", STDERR_FILENO);
		p->token_value = NULL;
		p->syntax_error = 1;
		return ;
	}
	content = ft_substr(p->input, start + 1, p->pos - start - 1);
	if (quote == '\'')
		p->token_type = T_SINGLE_QUOTED;
	else
		p->token_type = T_DOUBLE_QUOTED;
	free(p->token_value);
	p->token_value = content;
	next_char(p);
}

/*
** Handles regular words in input
** @param p Parser structure
*/
static void	handle_word(t_parse *p)
{
	size_t	start;
	char	*sub;

	start = p->pos;
	while (p->curr_char && !ft_isspace(p->curr_char)
		&& !is_special_char(p->curr_char))
	{
		next_char(p);
	}
	sub = ft_substr(p->input, start, p->pos - start);
	p->token_value = ft_strdup(sub);
	free(sub);
	p->token_type = T_WORD;
}

/*
** Gets the next token from input
** @param p Parser structure
*/
void	next_token(t_parse *p)
{
	skip_whitespace(p);
	free(p->token_value);
	p->token_value = NULL;
	if (!p->curr_char)
	{
		p->token_type = T_EOF;
		return ;
	}
	if (p->curr_char == '\'' || p->curr_char == '"')
		handle_quotes(p, p->curr_char);
	else if (p->curr_char == '|' || p->curr_char == ';' || p->curr_char == '>'
		|| p->curr_char == '<')
		handle_special(p);
	else
		handle_word(p);
}

/*
** Checks if a token type is a redirection
** @param type Token type to check
** @return 1 if redirection, 0 otherwise
*/
int	is_redirection(t_token type)
{
	return (type == T_REDIR_IN || type == T_REDIR_OUT
		|| type == T_APPEND || type == T_HEREDOC);
}

/**
 * @brief Converts a list of t_arg structs to an array of expanded strings.
 *
 * @param args Linked list of t_arg structs.
 * @return char** Array of expanded arguments. Must be freed with ft_free_array.
 */
char	**build_expanded_args(t_list *args)
{
	char		**arr;
	t_list		*current;
	int			i;
	t_arg		*a;

	arr = malloc(sizeof(char *) * (ft_lstsize(args) + 1));
	current = args;
	i = 0;
	while (current)
	{
		a = (t_arg *)current->content;
		if (a->type == T_SINGLE_QUOTED)
			arr[i++] = ft_strdup(a->value);
		else
			arr[i++] = expand_variables(a->value);
		current = current->next;
	}
	arr[i] = NULL;
	return (arr);
}

signals.c

#include "minishell.h"

/**
 * @brief Handles SIGINT (Ctrl+C) in interactive mode.
 * Prints a new prompt and resets input buffer.
 * @param sig Signal number (unused).
 */
void	handle_sigint(int sig)
{
	(void)sig;
	write(STDOUT_FILENO, "\n", 1);
	rl_replace_line("", 0);
	rl_on_new_line();
	rl_redisplay();
}

/*
** Sets up signal handlers for parent process (shell)
*/
void	setup_parent_signals(void)
{
	struct sigaction	sa;

	sa.sa_handler = handle_sigint;
	sa.sa_flags = SA_RESTART;
	sigemptyset(&sa.sa_mask);
	sigaction(SIGINT, &sa, NULL);
	signal(SIGQUIT, SIG_IGN);
}

/**
 * @brief Configures child processes to use default signal handlers.
 * SIGINT and SIGQUIT will terminate children normally.
 */
void	setup_child_signals(void)
{
	signal(SIGINT, SIG_DFL);
	signal(SIGQUIT, SIG_DFL);
}

void	setup_heredoc_signals(void)
{
	signal(SIGINT, SIG_DFL);
	signal(SIGQUIT, SIG_IGN);
}

utils.c

#include "minishell.h"

/*
** Frees an array of strings
** @param args Array to free
*/
void	ft_free_array(char **args)
{
	int	i;

	if (!args)
		return ;
	i = -1;
	while (args[++i])
		free(args[i]);
	free(args);
}

/*
** Checks if character is whitespace
** @param c Character to check
** @return 1 if whitespace, 0 otherwise
*/
int	ft_isspace(int c)
{
	return (c == ' ' || c == '\t' || c == '\n' || c == '\r'
		|| c == '\f' || c == '\v');
}

/*
** Advances to next character in parser input
** @param p Parser structure
*/
void	next_char(t_parse *p)
{
	if (p->input[p->pos])
	{
		p->pos++;
		p->curr_char = p->input[p->pos];
	}
	else
	{
		p->curr_char = '\0';
	}
}

/*
** Checks if character is special shell character
** @param c Character to check
** @return 1 if special, 0 otherwise
*/
int	is_special_char(char c)
{
	return (c == '|' || c == '>' || c == '<');
}

/*
** Converts a linked list to string array
** @param lst Linked list to convert
** @return New allocated string array
*/
char	**list_to_array(t_list *lst)
{
	char	**arr;
	int		count;
	int		i;
	t_list	*tmp;

	count = ft_lstsize(lst);
	arr = malloc((count + 1) * sizeof(char *));
	if (!arr)
		return (NULL);
	i = 0;
	tmp = lst;
	while (tmp)
	{
		arr[i] = ft_strdup((char *)tmp->content);
		if (!arr[i])
		{
			ft_free_array(arr);
			return (NULL);
		}
		tmp = tmp->next;
		i++;
	}
	arr[i] = NULL;
	return (arr);
}

/*
** Frees a command structure
** @param cmd Command to free
*/
void	free_cmd(t_cmd *cmd)
{
	t_redir	*redir;
	t_redir	*tmp;

	if (!cmd)
		return ;
	ft_free_array(cmd->args);
	redir = cmd->redirections;
	while (redir)
	{
		tmp = redir->next;
		free(redir->filename);
		free(redir);
		redir = tmp;
	}
	free(cmd);
}

/*
** String comparison
** @param s1 First string
** @param s2 Second string
** @return Difference between first differing characters
*/
int	ft_strcmp(const char *s1, const char *s2)
{
	while (*s1 && *s1 == *s2)
	{
		s1++;
		s2++;
	}
	return (*(unsigned char *)s1 - *(unsigned char *)s2);
}

/*
** Checks if string is numeric
** @param str String to check
** @return 1 if numeric, 0 otherwise
*/
int	ft_isnumber(const char *str)
{
	int	i;

	if (!str || !*str)
		return (0);
	i = 0;
	if (str[i] == '+' || str[i] == '-')
		i++;
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return (0);
		i++;
	}
	if (i > 0 && (str[0] == '+' || str[0] == '-'))
	{
		return (i > 1);
	}
	else
	{
		return (i > 0);
	}
}

/*
** Checks if string is valid variable name
** @param name String to check
** @return 1 if valid, 0 otherwise
*/
int	is_valid_var_name(const char *name)
{
	int	i;

	if (!name || !name[0] || ft_isdigit(name[0]))
		return (0);
	i = 0;
	while (name[i])
	{
		if (!ft_isalnum(name[i]) && name[i] != '_')
			return (0);
		i++;
	}
	return (1);
}

/*
** Prints environment variables in export format
*/
void	print_export_declarations(void)
{
	extern char	**environ;
	int			i;
	char		*eq;

	i = 0;
	while (environ[i])
	{
		eq = ft_strchr(environ[i], '=');
		if (eq)
		{
			*eq = '\0';
			printf("declare -x %s=\"%s\"\n", environ[i], eq + 1);
			*eq = '=';
		}
		else
			printf("declare -x %s\n", environ[i]);
		i++;
	}
}

/*
** Safe strlen that returns size_t
** @param str String to measure
** @return Length of string
*/
size_t	ft_strlen_size(const char *str)
{
	size_t	len;

	if (str)
		len = ft_strlen(str);
	else
		len = 0;
	return (len);
}

/*
** Joins three strings together
** @param s1 First string
** @param s2 Second string
** @param s3 Third string
** @return New concatenated string
*/
char	*ft_strjoin3(const char *s1, const char *s2, const char *s3)
{
	char	*tmp;
	char	*result;

	tmp = ft_strjoin(s1, s2);
	result = ft_strjoin(tmp, s3);
	free(tmp);
	return (result);
}

/**
 * @brief Appends an element to a NULL-terminated string array.
 * @param array Original array (freed after operation).
 * @param new_element Element to add.
 * @return New array with added element.
 */
char	**ft_array_append(char **array, char *new_element)
{
	int		count;
	char	**new_array;
	int		i;

	count = 0;
	while (array && array[count])
		count++;
	new_array = malloc(sizeof(char *) * (count + 2));
	if (!new_array)
		return (NULL);
	i = 0;
	while (array[i])
	{
		new_array[i] = array[i];
		i++;
	}
	new_array[count] = new_element;
	new_array[count + 1] = NULL;
	free(array);
	return (new_array);
}

/**
 * @brief Frees a t_arg structure and its contents.
 *
 * @param arg_ptr Pointer to a t_arg structure.
 */
void	free_arg(void *arg)
{
	t_arg	*a;

	a = (t_arg *)arg;
	free(a->value);
	free(a);
}

/**
 * @brief Concatenates two strings and frees the first string.
 *
 * @param s1 First string (will be freed). Can be NULL.
 * @param s2 Second string (not freed). Can be NULL.
 * @return char* New string containing `s1` + `s2`. NULL on allocation failure.
 */
char	*ft_strjoin_free(char *s1, const char *s2)
{
	char	*result;

	result = ft_strjoin(s1, s2);
	free(s1);
	return (result);
}

/**
 * @brief Safely appends a character to a string.
 * @param str Original string (freed after appending).
 * @param c Character to append.
 * @return New allocated string with appended character.
 */
char	*ft_strjoin_char(char *str, char c)
{
	char	*new_str;
	size_t	len;

	if (!str)
		len = 0;
	else
		len = ft_strlen(str);
	new_str = malloc(len + 2);
	if (!new_str)
		return (NULL);
	if (str)
		ft_memcpy(new_str, str, len);
	new_str[len] = c;
	new_str[len + 1] = '\0';
	free(str);
	return (new_str);
}

/**
 * @brief Counts the number of commands in a pipeline.
 *
 * @param pipeline Head of the command pipeline (linked list of t_cmd).
 * @return size_t Number of commands in the pipeline.
 * Returns 0 if pipeline is NULL.
 * @note Traverses the linked list of commands until reaching NULL.
 */
size_t	ft_cmd_size(t_cmd *pipeline)
{
	size_t	count;

	count = 0;
	while (pipeline)
	{
		count++;
		pipeline = pipeline->next;
	}
	return (count);
}

void	free_redirections(t_redir *redirs)
{
	t_redir	*tmp;

	while (redirs)
	{
		tmp = redirs->next;
		free(redirs->filename);
		free(redirs);
		redirs = tmp;
	}
}

/**
 * @brief Frees a copy of the environment variables.
 * @param env_copy The environment copy to free.
 */
void	free_env_copy(char **env_copy)
{
	if (!env_copy)
		return ;
	ft_free_array(env_copy);
}

void	syntax_error(char *token)
{
	ft_putstr_fd("minishell: syntax error near unexpected token '",
		STDERR_FILENO);
	if (!token || *token == '\0')
		ft_putstr_fd("newline", STDERR_FILENO);
	else
		ft_putstr_fd(token, STDERR_FILENO);
	ft_putstr_fd("'\n", STDERR_FILENO);
	set_exit_status(SYNTAX_ERROR);
}

char	*parse_fd(t_parse *p)
{
	int	start;

	start = p->pos;
	while (ft_isdigit(p->curr_char))
		next_char(p);
	return (ft_substr(p->input, start, p->pos - start));
}

/**
 * @brief Updates the quote state based on the current character.
 * @param c The current character.
 * @param in_quote Pointer to the in_quote flag.
 * @param quote_char Pointer to the current quote character.
 */
void	update_quote_state(char c, int *in_quote, char *quote_char)
{
	if (*in_quote && c == *quote_char)
		*in_quote = 0;
	else if (!*in_quote && (c == '\'' || c == '"'))
	{
		*in_quote = 1;
		*quote_char = c;
	}
}

/**
 * @brief Adds a substring to the result array.
 * @param result Pointer to the result array.
 * @param count Pointer to the current count of elements in the array.
 * @param start Pointer to the start of the substring.
 * @param end Pointer to the end of the substring.
 */
void	add_substring(char ***result, int *count,
				const char *start, const char *end)
{
	*result = realloc(*result, sizeof(char *) * (*count + 2));
	(*result)[(*count)++] = ft_substr(start, 0, end - start);
}

/**
 * @brief Handles a delimiter in the string, adding a
 *substring to the result array.
 * @param str Pointer to the current position in the string.
 * @param start Pointer to the start of the current substring.
 * @param result Pointer to the result array.
 * @param count Pointer to the current count of elements in the array.
 */
void	handle_delimiter(const char **str, const char **start,
	char ***result, int *count)
{
	add_substring(result, count, *start, *str);
	*start = *str + 1;
}

char	**split_with_quotes(const char *str, char delim)
{
	const char	*start;
	char		**result;
	int			count;
	int			in_quote;
	char		quote_char;

	start = str;
	result = NULL;
	count = 0;
	in_quote = 0;
	quote_char = '\0';
	while (*str)
	{
		if ((*str == '\'' || *str == '"'))
			update_quote_state(*str, &in_quote, &quote_char);
		else if (*str == delim && !in_quote)
			handle_delimiter(&str, &start, &result, &count);
		str++;
	}
	if (start != str)
		add_substring(&result, &count, start, str);
	if (result)
		result[count] = NULL;
	return (result);
}
